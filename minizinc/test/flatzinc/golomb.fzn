predicate oscar_all_disjoint(array [int] of var int: x);
predicate oscar_all_equal_int(array [int] of var int: x);
predicate oscar_alldiff(array [int] of var int: x);
predicate oscar_among(var int: n, array [int] of var int: x, set of int: v);
predicate oscar_at_least_int(int: n, array [int] of var int: x, int: v);
predicate oscar_at_most1(int: n, array [int] of var int: x, int: v);
predicate oscar_at_most_int(int: n, array [int] of var int: x, int: v);
predicate oscar_bin_packing(int: c, array [int] of var int: bin, array [int] of int: w);
predicate oscar_bin_packing_capa(array [int] of int: c, array [int] of var int: bin, array [int] of int: w);
predicate oscar_bin_packing_load(array [int] of var int: l, array [int] of var int: bin, array [int] of int: w);
predicate oscar_circuit(array [int] of var int: x);
predicate oscar_count_geq(array [int] of var int: x, var int: y, var int: c);
predicate oscar_count_gt(array [int] of var int: x, var int: y, var int: c);
predicate oscar_count_leq(array [int] of var int: x, var int: y, var int: c);
predicate oscar_count_lt(array [int] of var int: x, var int: y, var int: c);
predicate oscar_count_neq(array [int] of var int: x, var int: y, var int: c);
predicate oscar_cumulative(array [int] of var int: s, array [int] of var int: d, array [int] of var int: r, var int: b);
predicate oscar_decreasing_int(array [int] of var int: x);
predicate oscar_diffn(array [int] of var int: x, array [int] of var int: y, array [int] of var int: dx, array [int] of var int: dy);
predicate oscar_disjoint(var set of int: s, var set of int: t);
predicate oscar_distribute(array [int] of var int: card, array [int] of var int: value, array [int] of var int: base);
predicate oscar_element_bool(var int: i, array [int] of var bool: x, var bool: y);
predicate oscar_element_int(var int: i, array [int] of var int: x, var int: y);
predicate oscar_global_cardinality(array [int] of var int: x, array [int] of int: cover, array [int] of var int: counts);
predicate oscar_global_cardinality_closed(array [int] of var int: x, array [int] of int: cover, array [int] of var int: counts);
predicate oscar_global_cardinality_low_up(array [int] of var int: x, array [int] of int: cover, array [int] of int: lb, array [int] of int: ub);
predicate oscar_global_cardinality_low_up_closed(array [int] of var int: x, array [int] of int: cover, array [int] of int: lb, array [int] of int: ub);
predicate oscar_increasing_int(array [int] of var int: x);
predicate oscar_int_set_channel(array [int] of var int: x, array [int] of var set of int: y);
predicate oscar_inverse(array [int] of var int: f, array [int] of var int: invf);
predicate oscar_inverse_set(array [int] of var set of int: f, array [int] of var set of int: invf);
predicate oscar_lex2(array [int] of var int: x2, int: i, int: j);
predicate oscar_lex_less_int(array [int] of var int: x, array [int] of var int: y);
predicate oscar_lex_lesseq_int(array [int] of var int: x, array [int] of var int: y);
predicate oscar_link_set_to_booleans(var set of int: s, array [int] of var bool: b);
predicate oscar_maximum_int(var int: m, array [int] of var int: x);
predicate oscar_member_int(array [int] of var int: x, var int: y);
predicate oscar_minimum_int(var int: m, array [int] of var int: x);
predicate oscar_nvalue(var int: n, array [int] of var int: x);
predicate oscar_partition_set(array [int] of var set of int: s, set of int: universe);
predicate oscar_range(array [int] of var int: x, var set of int: s, var set of int: t);
predicate oscar_regular(array [int] of var int: x, int: Q, int: S, array [int] of int: d, int: q0, set of int: F);
predicate oscar_roots(array [int] of var int: x, var set of int: s, var set of int: t);
predicate oscar_sliding_sum(int: low, int: up, int: seq, array [int] of var int: vs);
predicate oscar_sort(array [int] of var int: x, array [int] of var int: y);
predicate oscar_strict_lex2(array [int] of var int: x2, int: i, int: j);
predicate oscar_subcircuit(array [int] of var int: x);
predicate oscar_sum_pred(var int: i, array [int] of set of int: sets, array [int] of int: c, var int: s);
predicate oscar_table_int(array [int] of var int: x, array [int] of int: t2);
predicate oscar_value_precede_chain_int(array [int] of int: c, array [int] of var int: x);
predicate oscar_value_precede_int(int: s, int: t, array [int] of var int: x);
var 0..24: INT____00001 :: is_defined_var :: var_is_introduced;
var 0..25: INT____00002 :: is_defined_var :: var_is_introduced;
var 0..25: INT____00003 :: is_defined_var :: var_is_introduced;
var 0..25: INT____00004 :: is_defined_var :: var_is_introduced;
var 0..25: INT____00005 :: is_defined_var :: var_is_introduced;
var 0..25: INT____00006 :: is_defined_var :: var_is_introduced;
var 0..25: INT____00007 :: is_defined_var :: var_is_introduced;
var 0..25: INT____00008 :: is_defined_var :: var_is_introduced;
var 0..25: INT____00009 :: is_defined_var :: var_is_introduced;
var 1..25: INT____00010 :: is_defined_var :: var_is_introduced;
array [1..10] of var 0..25: differences = [INT____00001, INT____00002, INT____00003, INT____00004, INT____00005, INT____00006, INT____00007, INT____00008, INT____00009, INT____00010];
array [1..5] of var 0..25: mark :: output_array([1..5]);
constraint int_eq(mark[1], 0);
constraint int_lin_eq([-1, -1, 1], [INT____00001, mark[1], mark[2]], 0) :: defines_var(INT____00001);
constraint int_lin_eq([-1, -1, 1], [INT____00002, mark[1], mark[3]], 0) :: defines_var(INT____00002);
constraint int_lin_eq([-1, -1, 1], [INT____00003, mark[1], mark[4]], 0) :: defines_var(INT____00003);
constraint int_lin_eq([-1, -1, 1], [INT____00004, mark[1], mark[5]], 0) :: defines_var(INT____00004);
constraint int_lin_eq([-1, -1, 1], [INT____00005, mark[2], mark[3]], 0) :: defines_var(INT____00005);
constraint int_lin_eq([-1, -1, 1], [INT____00006, mark[2], mark[4]], 0) :: defines_var(INT____00006);
constraint int_lin_eq([-1, -1, 1], [INT____00007, mark[2], mark[5]], 0) :: defines_var(INT____00007);
constraint int_lin_eq([-1, -1, 1], [INT____00008, mark[3], mark[4]], 0) :: defines_var(INT____00008);
constraint int_lin_eq([-1, -1, 1], [INT____00009, mark[3], mark[5]], 0) :: defines_var(INT____00009);
constraint int_lin_eq([-1, -1, 1], [INT____00010, mark[4], mark[5]], 0) :: defines_var(INT____00010);
constraint int_lt(INT____00001, INT____00010);
constraint int_lt(mark[1], mark[2]);
constraint int_lt(mark[2], mark[3]);
constraint int_lt(mark[3], mark[4]);
constraint int_lt(mark[4], mark[5]);
constraint oscar_alldiff(differences);
solve  :: int_search(mark, input_order, indomain, complete) minimize mark[5];

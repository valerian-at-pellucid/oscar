/*******************************************************************************
 * OscaR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 2.1 of the License, or
 * (at your option) any later version.
 *   
 * OscaR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License  for more details.
 *   
 * You should have received a copy of the GNU Lesser General Public License along with OscaR.
 * If not, see http://www.gnu.org/licenses/lgpl-3.0.en.html
 ******************************************************************************/
package oscar.dfo.singleobjective

import oscar.dfo.utils._

/** A Derivative Free Optimization (DFO) Solver.
  *
  * The classes using this trait should implement the following function:
  *   optimize: Performs the optimization algorithm once from the starting point
  *   sampledOptimize: Performs many times the optimization algorithm from starting points
  *                    generated by quasi-random sequences
  *   putInDomain: puts a point out of the domain within the domain
  *
  * The classes using the trait are DDS, DMS and NelderMead 
  * @author Cyrille Dejemeppe 
  */
trait SODFOptimizer {
  
  /** The number of function evaluations performed */
  var evalCount = 0
  
  /** The evaluator that will be used to get function evaluations */
  val evaluator = new DeterministicEvaluation()
  
  /** The random number generator */
  val rand = SODFOptimizer.randGen
  
  /** The quasi-random sequences generator */
  val sampler = SODFOptimizer.samplerGen
  
  /** The simplex (polyhedron) data structure */
  var simplex = Array[(Array[Double], Array[Double])]()
  
  var currentBest: (Array[Double], Array[Double])
  
  /** Performs the optimization algorithm once from the starting point.
    * 
    * @param tol The tolerance which defines the desired level of precision
    * @param evalLimit The maximum number of evaluations before stopping the algorithm
    * @param timeLimit The maximum time to spend before stopping the algorithm
    * @return A tuple whose first element is the optimal point found and whose
    *         second element is the evaluations of the functions at this point */
  def optimize(tol: Double, evalLimit: Int, timeLimit: Int): (Array[Double], Array[Double])
  
  /** Performs the optimization algorithm many times from different starting points
    * generated by quasi-random sequences.
    * 
    * @param nbSamples The number of starting points to consider (will define
    *        the size of the quasi-random sequence representing starting points)
    * @param tol The tolerance which defines the desired level of precision
    * @return A tuple whose first element is the optimal point found among all algorithm
    *         executions and whose second element is the evaluations of the functions at
    *         this point */
  def sampledOptimize(nbSamples: Int, tol: Double): (Array[Double], Array[Double])
  
  /** Returns a point that is the initial point if it was already lying
    * within the domain otherwise the closest point in the domain to the
    * one specified as parameter.
    *
    * @param x The point we want to lie within the domain
    * @return An array of double that is the closest point lying within
    *         the domain from the point specified as parameter */
  def putInDomain(x: Array[Double]): Array[Double]
  
  /** Returns a string representation of an array of Double.
    * 
    * @param point An array of Double
    * @return A String that is the representation of the array of Double specified
    *         as parameter under the syntax (e1, e2, ..., en) */
  def pointToStr(point: Array[Double]) : String = {
    var res = "("
    for(i <- 0 to point.length - 2)
      res += point(i) + ", "
    res += point(point.length - 1) + ")"
    res
  }
  
  /** Returns the best points of one iteration of the algorithm
    *
    * @return A list of tuples, each tuples conatining two arrays of Double,
    *         the first one being a point within the domain and the second
    *         one being the evaluations of the functions at this point */
  def iter(): List[(Array[Double], Array[Double])]
  
  /** Returns the diameter of the 95% confidence interval according to
    * the parameters.
    * 
    * @param alpha The alpha representing the advancement of the algorithm
    * @param tol The tolerance representing the level of precision we want
    *            to obtain
    * @param max The maximal value for alpha
    * @return A Double that is the diameter of a 95% confidence interval */
  def confIntervSize(alpha: Double, tol: Double, max: Double): Double = {
    val normalizedAlpha = (alpha / tol) + tol
    math.max(tol, math.log(normalizedAlpha) / math.log(max))
  }
  
  /** Returns true if the two points are equal, false otherwise.
    *
    * @param p1 An array of Double that is to be compared with p2
    * @param p2 An array of Double that is to be compared with p1
    * @return A Boolean that is true if p1 and p2 contains the same
    *         elements at the same indexes */
  def areEqual(p1: Array[Double], p2: Array[Double]): Boolean = {
    for (i <- 0 until p1.length) {
      if (p1(i) != p2(i))
        return false
    }
    true
  }
  
  /** The maximal bounds for the alpha (advancement parameter) */
  var maxAlpha = Array(Double.MaxValue)
  
  /** The advancement (or step size) parameter */
  var alpha = Array.tabulate(1)(i => 0.0)
  
  /** Returns the diameter of the current simplex.
    *
    * The diameter of a simplex is defined as the maximal distance from
    * a vertex of the simplex to the best (minimal) vertex of the simplex.
    *
    * @return A double that is the diameter of the simplex */
  def simplexDiameter: Double
  
  /** Function to be called after the algorithm performed a successful iteration */
  var onImprovement: () => Unit = () => {}
  
  /** Returns the euclidian distance between p1 and p2.
    * 
    * @param p1 Array of double representing point coordinates
    * @param p2 Array of double representing point coordinates
    * @return A Double being the euclidian distance between p1 and p2
    */
  def pointDistance(p1: Array[Double], p2: Array[Double]): Double = {
    var norm = 0.0
    for (i <- 0 until p1.length)
      norm += math.pow((p2(i) - p1(i)), 2)
    math.sqrt(norm)
  }
}

/** Used to have a single random number generator and a single quasi-random
  * sequence generator for all the DFO algorithms. */ 
object SODFOptimizer{
  
  /** A random number generator */
  val randGen = new scala.util.Random(42)
  
  /** A quasi-random sequence generator */
  val samplerGen = new QuasiRandomSequence(randGen)
}
